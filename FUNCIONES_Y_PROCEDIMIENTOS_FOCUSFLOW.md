# FUNCIONES Y PROCEDIMIENTOS - FOCUSFLOW

## FUNCIONES PRINCIPALES DEL SISTEMA

### Sistema de Alarmas Inteligentes

La función createAlarm permite al usuario crear alarmas personalizadas que se adaptan a sus necesidades específicas. Esta función recibe como parámetros la hora deseada, el mensaje motivacional que se mostrará, el tipo de sonido que se reproducirá y la configuración de repetición. El sistema valida automáticamente que la hora ingresada sea válida y que todos los campos obligatorios estén completos antes de crear la alarma. Una vez validados los datos, se genera un identificador único para la alarma utilizando una combinación de timestamp y números aleatorios, lo que garantiza que cada alarma sea única en el sistema. La alarma creada se almacena en el LocalStorage del navegador para persistir entre sesiones, y se programa su ejecución utilizando las APIs nativas del navegador.

La función triggerAlarm se encarga de ejecutar una alarma cuando llega su hora programada. Primero verifica que la alarma esté activa y no haya sido desactivada por el usuario. Si la alarma está activa, reproduce el sonido configurado ajustando el volumen según las preferencias del usuario. Simultáneamente, muestra una notificación del navegador utilizando la Notifications API, siempre y cuando el usuario haya otorgado los permisos necesarios. Además, despliega un modal en la aplicación con el mensaje motivacional personalizado y opciones para detener la alarma o posponerla. El sistema registra cada ejecución de alarma en el historial del usuario para análisis posterior. Si la alarma está configurada como recurrente, el sistema calcula automáticamente la próxima ejecución basándose en el intervalo configurado y la programa nuevamente.

La función snoozeAlarm permite al usuario posponer una alarma por un período determinado, generalmente cinco o diez minutos. Esta función detiene temporalmente la alarma actual, calcula el nuevo tiempo de ejecución sumando los minutos de posposición al tiempo actual, y reprograma la alarma para ese nuevo horario. El sistema mantiene un contador de cuántas veces se ha pospuesto una alarma para mostrar estadísticas al usuario y ayudarle a identificar patrones de procrastinación.

### Gestión de Tareas

La función createTask es responsable de crear nuevas tareas en el sistema. Recibe un objeto con toda la información de la tarea incluyendo título, descripción, nivel de prioridad, fecha límite, categoría y subtareas opcionales. El sistema valida que el título no esté vacío y que la fecha límite, si se proporciona, sea una fecha futura válida. Cada tarea recibe un identificador único y se marca inicialmente como no completada. La tarea se guarda en el LocalStorage y se actualiza la interfaz de usuario para mostrar la nueva tarea en la lista correspondiente según su prioridad y categoría.

La función completeTask marca una tarea como completada y ejecuta una serie de acciones relacionadas. Primero actualiza el estado de la tarea en el almacenamiento, registrando la fecha y hora exacta de completación. Luego actualiza las estadísticas del usuario incrementando el contador de tareas completadas y recalculando el porcentaje de progreso general. El sistema muestra un mensaje motivacional aleatorio seleccionado de una colección de frases positivas diseñadas para reforzar el comportamiento productivo. Finalmente, se ejecuta una animación visual en la interfaz para celebrar el logro, lo que proporciona retroalimentación inmediata y satisfactoria al usuario.

La función filterTasks permite al usuario filtrar sus tareas según múltiples criterios. Puede filtrar por nivel de prioridad mostrando solo tareas de alta, media o baja prioridad. También puede filtrar por categoría para enfocarse en un área específica como trabajo, estudio o personal. El filtro por estado permite ver solo tareas pendientes, completadas o todas. Adicionalmente, se puede filtrar por rango de fechas para ver tareas con fechas límite en un período específico. La función procesa el array de tareas aplicando los criterios seleccionados y retorna un nuevo array con las tareas que cumplen todos los filtros activos.

### Temporizador Pomodoro

La función startPomodoro inicia una sesión de trabajo utilizando la técnica Pomodoro. Por defecto configura un temporizador de veinticinco minutos, aunque el usuario puede personalizar esta duración. Al iniciar, el sistema crea un objeto que almacena toda la información de la sesión incluyendo la duración total, el tiempo restante, el estado actual y la hora de inicio. Este objeto se guarda en el LocalStorage para que la sesión persista incluso si el usuario cierra accidentalmente la aplicación. El sistema inicia un contador regresivo que actualiza la interfaz cada segundo mostrando el tiempo restante de manera clara y visible. Durante la sesión activa, se activa automáticamente el modo enfoque que minimiza distracciones visuales en la interfaz y puede bloquear notificaciones externas si el usuario lo ha configurado así.

La función pausePomodoro permite al usuario pausar temporalmente el temporizador sin perder el progreso. Cuando se pausa, el sistema guarda el tiempo restante exacto y detiene el contador regresivo. La interfaz se actualiza para mostrar claramente que la sesión está en pausa y ofrece la opción de reanudar. Esta funcionalidad es importante porque reconoce que pueden surgir interrupciones inevitables y permite al usuario manejarlas sin perder todo el progreso de la sesión.

La función resumePomodoro reanuda una sesión pausada desde el punto exacto donde se detuvo. Recupera el tiempo restante guardado y reinicia el contador regresivo. El modo enfoque se reactiva automáticamente para ayudar al usuario a retomar la concentración rápidamente.

### Mensajes Motivacionales

La función getRandomMotivationalMessage selecciona y retorna un mensaje motivacional apropiado según el contexto. El sistema mantiene diferentes categorías de mensajes incluyendo mensajes matutinos para comenzar el día con energía, mensajes de logro para celebrar tareas completadas, mensajes de enfoque para mantener la concentración durante el trabajo, mensajes de descanso para recordar la importancia de las pausas, y mensajes generales de ánimo. La función recibe como parámetro la categoría deseada y selecciona aleatoriamente un mensaje de esa categoría para evitar la repetición y mantener la frescura de la experiencia.

La función displayMotivationalModal muestra un mensaje motivacional en un modal visualmente atractivo. El modal aparece con una animación suave que capta la atención sin ser intrusiva. El diseño del modal utiliza colores cálidos y positivos, iconos relevantes y tipografía clara para maximizar el impacto emocional positivo del mensaje. El usuario puede cerrar el modal con un clic o automáticamente después de unos segundos.

### Sistema de Notificaciones

La función requestNotificationPermission solicita al usuario permiso para mostrar notificaciones del navegador. Esta función verifica primero si el navegador soporta la Notifications API. Si el permiso ya ha sido otorgado previamente, retorna inmediatamente. Si el permiso está pendiente, muestra el diálogo nativo del navegador explicando por qué la aplicación necesita este permiso. El sistema maneja elegantemente los tres posibles estados: permiso otorgado, permiso denegado y permiso pendiente.

La función showNotification crea y muestra una notificación del navegador con el contenido especificado. Recibe parámetros para el título, el cuerpo del mensaje, el icono a mostrar y opciones adicionales como si la notificación requiere interacción del usuario para cerrarse. La función verifica que los permisos estén otorgados antes de intentar mostrar la notificación. Si los permisos no están disponibles, muestra el mensaje en la interfaz de la aplicación como alternativa.

### Almacenamiento Local

La función saveToLocalStorage maneja el guardado de datos en el LocalStorage del navegador. Recibe una clave identificadora y los datos a guardar, que pueden ser de cualquier tipo. La función convierte automáticamente los datos a formato JSON antes de guardarlos, lo que permite almacenar objetos complejos y arrays. Implementa manejo de errores para capturar problemas como exceder el límite de almacenamiento del navegador o errores de serialización.

La función getFromLocalStorage recupera datos previamente guardados. Recibe la clave identificadora y retorna los datos deserializados a su formato original. Si la clave no existe o hay un error al recuperar los datos, retorna null de manera segura. Esta función es fundamental para mantener la persistencia de datos entre sesiones de usuario.

## PROCEDIMIENTOS DEL SISTEMA

### Procedimiento de Inicialización de la Aplicación

Cuando el usuario abre la aplicación FocusFlow, el sistema ejecuta una secuencia de inicialización cuidadosamente diseñada. Primero verifica que el navegador del usuario soporte todas las características necesarias incluyendo LocalStorage, Notifications API y Service Workers. Si alguna característica crítica no está disponible, el sistema muestra un mensaje informativo al usuario explicando las limitaciones. Luego intenta cargar la configuración guardada del usuario desde el LocalStorage. Si es la primera vez que el usuario accede a la aplicación, se crea una configuración por defecto con valores sensatos. El sistema solicita los permisos necesarios como notificaciones, explicando claramente por qué cada permiso es importante para la funcionalidad de la aplicación. Después carga todos los datos guardados del usuario incluyendo alarmas programadas, tareas pendientes, historial de actividades y estadísticas acumuladas. Cada componente de la aplicación se inicializa en el orden correcto para evitar dependencias no resueltas. La interfaz se renderiza mostrando el dashboard principal con todos los contadores y métricas actualizadas. Finalmente, el sistema programa todas las alarmas activas calculando cuándo debe ejecutarse cada una y configurando los temporizadores correspondientes.

### Procedimiento de Creación de Alarma

Cuando el usuario decide crear una nueva alarma, hace clic en el botón correspondiente y el sistema muestra un formulario modal con todos los campos necesarios. El usuario ingresa la hora deseada utilizando un selector de tiempo intuitivo que previene errores de formato. Escribe un mensaje personalizado que se mostrará cuando la alarma se active, o puede seleccionar de una lista de mensajes predefinidos. Elige el sonido de alarma de una colección de tonos suaves diseñados para no ser estresantes. Configura si la alarma debe repetirse y con qué frecuencia, pudiendo elegir entre diaria, días específicos de la semana o intervalos personalizados. Cuando el usuario hace clic en guardar, el sistema valida todos los campos asegurándose de que la hora sea válida y que el mensaje no esté vacío. Si hay errores de validación, se muestran mensajes claros indicando qué debe corregirse. Una vez validados los datos, se crea el objeto de alarma con un identificador único generado usando la fecha actual y un componente aleatorio. La alarma se guarda en el LocalStorage para persistir entre sesiones. El sistema calcula cuánto tiempo falta hasta la próxima ejecución de la alarma y programa un temporizador usando setTimeout o setInterval según corresponda. La lista de alarmas en la interfaz se actualiza inmediatamente mostrando la nueva alarma con todos sus detalles. Se muestra un mensaje de confirmación al usuario indicando que la alarma fue creada exitosamente. El formulario se cierra automáticamente y el usuario regresa a la vista principal de alarmas.

### Procedimiento de Ejecución de Alarma

Cuando llega el momento programado para una alarma, el sistema verifica primero que la alarma siga activa y no haya sido desactivada por el usuario. Si la alarma está activa, comienza la secuencia de ejecución. Primero carga el archivo de audio configurado para esa alarma y lo reproduce ajustando el volumen según las preferencias del usuario. El audio se reproduce en loop para asegurar que el usuario lo escuche. Simultáneamente, si el usuario ha otorgado permisos de notificaciones, el sistema crea una notificación del navegador con el título de la aplicación y el mensaje personalizado de la alarma. La notificación incluye el icono de la aplicación y se configura para requerir interacción del usuario. En la aplicación misma, se muestra un modal prominente con el mensaje motivacional, utilizando colores llamativos y animaciones para captar la atención. El modal incluye dos botones principales: uno para detener la alarma completamente y otro para posponerla por cinco minutos. El usuario puede interactuar con cualquiera de estas opciones. Si elige detener la alarma, el sistema detiene inmediatamente la reproducción del audio, cierra el modal y la notificación, y registra en el historial que la alarma fue atendida. Si la alarma está configurada como recurrente, el sistema calcula automáticamente cuándo debe ejecutarse nuevamente basándose en el intervalo configurado y la programa para ese momento. Si el usuario elige posponer, el audio se detiene temporalmente, el modal se cierra, y la alarma se reprograma para ejecutarse en cinco minutos. Se muestra un mensaje breve indicando que la alarma fue pospuesta. Independientemente de la acción del usuario, el sistema actualiza las estadísticas incrementando el contador de alarmas ejecutadas y registrando la hora exacta de ejecución para análisis posterior.

### Procedimiento de Gestión de Tareas

Cuando el usuario accede a la sección de tareas, el sistema carga todas las tareas guardadas desde el LocalStorage. Aplica automáticamente cualquier filtro que el usuario haya configurado previamente, como mostrar solo tareas de alta prioridad o solo tareas de una categoría específica. Las tareas se ordenan según el criterio seleccionado por el usuario, que puede ser por prioridad, fecha límite, fecha de creación o alfabéticamente. La lista de tareas se renderiza en la interfaz mostrando cada tarea con su título, descripción breve, indicador visual de prioridad mediante colores, fecha límite si existe, y un checkbox para marcarla como completada. Cada tarea también muestra botones de acción para editar o eliminar. Cuando el usuario interactúa con una tarea, el sistema responde inmediatamente. Si marca el checkbox de completada, la tarea se actualiza visualmente con una animación de tachado, se muestra un mensaje motivacional celebrando el logro, se actualiza el contador de progreso general, y los cambios se guardan en el LocalStorage. Si el usuario hace clic en editar, se abre un formulario modal precargado con los datos actuales de la tarea permitiendo modificar cualquier campo. Cuando guarda los cambios, el sistema valida los nuevos datos, actualiza la tarea en el almacenamiento y refresca la visualización. Si el usuario elige eliminar una tarea, el sistema muestra primero un diálogo de confirmación para prevenir eliminaciones accidentales. Si el usuario confirma, la tarea se elimina del almacenamiento, se ejecuta una animación de salida y la lista se actualiza. Todas estas operaciones actualizan las estadísticas generales del usuario en tiempo real.

### Procedimiento del Ciclo Pomodoro Completo

Cuando el usuario decide iniciar una sesión Pomodoro, hace clic en el botón de inicio y el sistema configura un temporizador de veinticinco minutos por defecto. El usuario puede ajustar esta duración antes de iniciar si lo desea. Al comenzar, el sistema activa el modo enfoque que modifica la interfaz para minimizar distracciones, ocultando elementos no esenciales y usando colores más neutros. Se inicia un contador regresivo que actualiza la pantalla cada segundo mostrando claramente el tiempo restante en formato de minutos y segundos. Una barra de progreso visual complementa el contador numérico proporcionando una representación gráfica del avance. Durante la sesión, el usuario puede pausar el temporizador si surge una interrupción inevitable, y puede reanudarlo cuando esté listo para continuar. El sistema monitorea constantemente el tiempo restante. Cuando el temporizador llega a cero, se reproduce un sonido suave de finalización, se muestra una notificación del navegador si los permisos están otorgados, y aparece un modal en la aplicación felicitando al usuario por completar la sesión. El sistema registra automáticamente el Pomodoro completado en el historial y actualiza las estadísticas del usuario. El modal ofrece al usuario dos opciones: iniciar un descanso de cinco minutos o saltar el descanso y volver al dashboard. Si el usuario elige iniciar el descanso, el sistema configura un nuevo temporizador de cinco minutos y cambia el tema visual a colores más relajantes. Durante el descanso, se muestran sugerencias de actividades relajantes como estiramientos, respiración profunda o caminar brevemente. Cuando el descanso termina, se notifica al usuario y se le ofrece la opción de iniciar otra sesión de trabajo. El sistema lleva un contador de Pomodoros completados en la sesión actual. Después de completar cuatro Pomodoros, el sistema recomienda automáticamente un descanso más largo de quince a treinta minutos para prevenir el agotamiento. Todas estas actividades se registran en el historial del usuario y contribuyen a las estadísticas de productividad que se muestran en el dashboard.
